/*
  Front-end renderer for data/latest.json (generated by GitHub Actions).

  UX goals (based on your reference screenshot):
  - compact status table
  - filter bar (ICAO/IATA/name)
  - “All conditions” selector
  - “Sort by priority” toggle
  - explicit columns (Alert / VIS / flags / triggers / ages / raw)
*/

const DATA_URL = 'data/latest.json';
const dataUrl = () => `${DATA_URL}?ts=${Date.now()}`;
const STATUS_URL = 'data/status.json';
const REFRESH_MS = 10 * 60 * 1000;

const $ = (sel) => document.querySelector(sel);
const byId = (id) => document.getElementById(id);

function escapeHtml(s){
  return (s ?? '').replace(/[&<>"']/g, (c) => ({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
  }[c]));
}

function formatGeneratedAt(s){
  if(!s) return '—';
  const t = Date.parse(s);
  if(Number.isNaN(t)) return '—';
  return new Date(t).toLocaleString();
}


function clamp(n, a, b){
  return Math.max(a, Math.min(b, n));
}

function levelFromScore(score){
  if (score >= 70) return { label: 'CRIT', cls: 'pill pill--crit' };
  if (score >= 45) return { label: 'HIGH', cls: 'pill pill--high' };
  if (score >= 20) return { label: 'MED',  cls: 'pill pill--med' };
  return { label: 'OK',   cls: 'pill pill--ok' };
}

function hasEngineIcingStopFlag(item){
  // High-priority operational flag (user-defined):
  // VIS ≤ 150 m AND FZFG present (evaluated separately for METAR vs TAF).
  if(item && (item._engIceM || item._engIceT)) return true;
  // Fallback (should not happen once derivePerStation ran)
  const metVis = visNumber(item?.visibility_m ?? visMinFromRaw(item?.metarRaw));
  const tafVis = visMinFromRaw(item?.tafRaw);
  const hm = hazardsFromRaw(item?.metarRaw);
  const ht = hazardsFromRaw(item?.tafRaw);
  const engM = (metVis != null && metVis <= 150) && hm.has('FZFG');
  const engT = (tafVis != null && tafVis <= 150) && ht.has('FZFG');
  return engM || engT;
}

function displayScore(item){
  // Keep the server-provided score, but allow a local UI override for special stop-flags.
  const base = Math.round(item.severityScore ?? 0);
  if(hasEngineIcingStopFlag(item)) return Math.max(base, 95);
  return base;
}

function parseDdhhmmZ(raw){
  // Finds the first DDHHMMZ group.
  if (!raw) return null;
  const m = raw.match(/\b(\d{2})(\d{2})(\d{2})Z\b/);
  if(!m) return null;
  return { dd: Number(m[1]), hh: Number(m[2]), mm: Number(m[3]) };
}

function obsTimeUtcFromGroup(ddhhmm, baseIso){
  // METAR/TAF has day-of-month (DD) without month/year.
  // Build a UTC Date close to base by trying month-1, month, month+1 and picking the closest.
  if(!ddhhmm || !baseIso) return null;
  const base = new Date(baseIso);
  if(Number.isNaN(base.getTime())) return null;

  const y = base.getUTCFullYear();
  const m = base.getUTCMonth();
  const candidates = [m-1, m, m+1].map(mm => {
    const d = new Date(Date.UTC(y, mm, ddhhmm.dd, ddhhmm.hh, ddhhmm.mm, 0));
    return d;
  });
  let best = candidates[0];
  let bestAbs = Math.abs(best.getTime() - base.getTime());
  for(const c of candidates.slice(1)){
    const abs = Math.abs(c.getTime() - base.getTime());
    if(abs < bestAbs){ best = c; bestAbs = abs; }
  }
  return best;
}

function ageMinutes(raw, baseIso){
  // “How many minutes ago was it issued/observed” (relative to *now* by default).
  const g = new Date(baseIso);
  if(Number.isNaN(g.getTime())) return null;
  const group = parseDdhhmmZ(raw);
  const t = obsTimeUtcFromGroup(group, baseIso);
  if(!t) return null;
  const mins = Math.round((g.getTime() - t.getTime()) / 60000);
  if(!Number.isFinite(mins)) return null;
  // If something is weird (e.g. older than ~2 days), still show but clamp negatives.
  return clamp(mins, 0, 9999);
}

function visNumber(m){
  if(m == null) return null;
  if(m === 9999) return 10000;
  return m;
}

function minNonNull(...vals){
  const v = vals.filter(x => x != null && Number.isFinite(x));
  if(!v.length) return null;
  return Math.min(...v);
}

function hazardsFromRaw(raw){
  const out = new Set();
  if(!raw) return out;
  const toks = String(raw).split(/\s+/).filter(Boolean);
  for(const tok0 of toks){
    let tok = tok0.toUpperCase();
    // strip intensity
    tok = tok.replace(/^[-+]/,'');
    // remove vicinity prefix
    if(tok.startsWith('VC')) tok = tok.slice(2);

    // TS group
    if(tok.includes('TS')) out.add('TS');

    // Fog / mist
    if(tok.includes('FZFG')) out.add('FZFG');
    if(tok.includes('FG')) out.add('FG'); // includes MIFG/BCFG/VCFG etc.
    if(tok === 'BR' || tok.includes('BR')) out.add('BR');

    // Snow / ice pellets
    if(/SN|SHSN|BLSN|DRSN|SG|PL/.test(tok)) out.add('SN');

    // Rain / drizzle / freezing precip
    if(/RA|SHRA|DZ|FZRA|FZDZ/.test(tok)) out.add('RA');
  }
  return out;
}

function visMinFromTokens(tokens){
  // Returns minimum visibility in meters found in a token list.
  let min = null;
  for(let i=0;i<tokens.length;i++){
    const t0 = tokens[i].toUpperCase();

    if(t0 === 'CAVOK'){
      min = (min == null) ? 10000 : Math.min(min, 10000);
      continue;
    }

    // 4-digit meters
    if(/^\d{4}$/.test(t0)){
      const v = parseInt(t0,10);
      if(Number.isFinite(v)){
        const vm = (v === 9999) ? 10000 : v;
        min = (min == null) ? vm : Math.min(min, vm);
      }
      continue;
    }

    // statute miles (single token)
    const sm = parseSmToMeters(t0);
    if(sm != null){
      const vm = Math.round(sm);
      min = (min == null) ? vm : Math.min(min, vm);
      continue;
    }

    // statute miles split: "1" + "1/2SM"
    if(/^\d+$/.test(t0) && i+1 < tokens.length && /^[0-9]+\/[0-9]+SM$/i.test(tokens[i+1])){
      const whole = parseInt(t0,10);
      const fracM = parseSmToMeters(tokens[i+1]);
      if(Number.isFinite(whole) && fracM != null){
        const vm = Math.round(whole * 1609.344 + fracM);
        min = (min == null) ? vm : Math.min(min, vm);
      }
      continue;
    }
  }
  return min;
}

function visMinFromRaw(raw){
  if(!raw) return null;
  return visMinFromTokens(String(raw).split(/\s+/).filter(Boolean));
}

function rvrMinFromRaw(raw){
  const vals = extractRvrValuesMeters(raw);
  if(!vals.length) return null;
  return Math.min(...vals);
}

function ceilingMinFtFromRaw(raw){
  // Ceiling = lowest BKN/OVC/VV base in feet (AGL)
  if(!raw) return null;
  const toks = String(raw).split(/\s+/).filter(Boolean);
  let min = null;
  for(const t0 of toks){
    const t = t0.toUpperCase();
    if(/^(BKN|OVC|VV)\d{3}/.test(t)){
      const n = parseInt(t.slice(-3), 10);
      if(Number.isFinite(n)){
        const ft = n * 100;
        min = (min == null) ? ft : Math.min(min, ft);
      }
    }
  }
  return min;
}

function derivePerStation(s){
  const metarRaw = s?.metarRaw || '';
  const tafRaw = s?.tafRaw || '';

  const hazM = hazardsFromRaw(metarRaw);
  const hazT = hazardsFromRaw(tafRaw);

  const metVis = visNumber(s?.visibility_m ?? visMinFromRaw(metarRaw));
  const tafVis = visMinFromRaw(tafRaw);
  const worstVis = minNonNull(metVis, tafVis);

  const metRvr = rvrMinFromRaw(metarRaw);
  const tafRvr = rvrMinFromRaw(tafRaw);
  const rvrMin = minNonNull(metRvr, tafRvr);

  const metCig = (s?.ceiling_ft != null) ? s.ceiling_ft : ceilingMinFtFromRaw(metarRaw);
  const tafCig = ceilingMinFtFromRaw(tafRaw);
  const cigMin = minNonNull(metCig, tafCig);

  const engIceM = (metVis != null && metVis <= 150) && hazM.has('FZFG');
  const engIceT = (tafVis != null && tafVis <= 150) && hazT.has('FZFG');

  return {
    hazM: Array.from(hazM),
    hazT: Array.from(hazT),
    metVis,
    tafVis,
    worstVis,
    metRvr,
    tafRvr,
    rvrMin,
    metCig,
    tafCig,
    cigMin,
    engIceM,
    engIceT,
  };
}

function buildTriggers(item){
  const tags = [];
  const d = item?._d || derivePerStation(item);
  const hazM = new Set(d.hazM || []);
  const hazT = new Set(d.hazT || []);

  const push = (t, key, m, tt) => {
    if(!m && !tt) return;
    tags.push({ t, key, srcM: !!m, srcT: !!tt });
  };

  // Engine operations stop-flag (highest priority)
  if(d.engIceM || d.engIceT){
    tags.push({ t: 'ENG ICE OPS', key: 'eng', srcM: !!d.engIceM, srcT: !!d.engIceT });
  }

  // VIS threshold (worst across METAR vs TAF)
  const vis = d.worstVis;
  const metVis = d.metVis;
  const tafVis = d.tafVis;

  if(vis != null){
    const thresholds = [
      {v:150, key:'vis150', t:'VIS≤150'},
      {v:175, key:'vis175', t:'VIS≤175'},
      {v:250, key:'vis250', t:'VIS≤250'},
      {v:300, key:'vis300', t:'VIS≤300'},
      {v:500, key:'vis500', t:'VIS≤500'},
      {v:550, key:'vis550', t:'VIS≤550'},
      {v:800, key:'vis800', t:'VIS≤800'},
    ];
    for(const th of thresholds){
      if(vis <= th.v){
        push(th.t, th.key, (metVis != null && metVis <= th.v), (tafVis != null && tafVis <= th.v));
        break;
      }
    }
  }

  // RVR threshold (min across METAR vs TAF)
  const rvr = d.rvrMin;
  const metRvr = d.metRvr;
  const tafRvr = d.tafRvr;
  if(rvr != null){
    const thresholds = [
      {v:75, key:'rvr75', t:'RVR≤75'},
      {v:200, key:'rvr200', t:'RVR≤200'},
      {v:300, key:'rvr300', t:'RVR≤300'},
      {v:500, key:'rvr500', t:'RVR≤500'},
    ];
    for(const th of thresholds){
      if(rvr <= th.v){
        push(th.t, th.key, (metRvr != null && metRvr <= th.v), (tafRvr != null && tafRvr <= th.v));
        break;
      }
    }
  }

  // FZFG (explicit)
  push('FZFG', 'fzfg', hazM.has('FZFG'), hazT.has('FZFG'));

  // Fog / mist (show FG if present, else BR)
  if(hazM.has('FG') || hazT.has('FG')){
    push('FG', 'fog', hazM.has('FG'), hazT.has('FG'));
  }else{
    push('BR', 'fog', hazM.has('BR'), hazT.has('BR'));
  }

  // TS
  push('TS', 'ts', hazM.has('TS'), hazT.has('TS'));

  // Snow
  push('SN', 'snow', hazM.has('SN'), hazT.has('SN'));

  // Rain
  push('RA', 'rain', hazM.has('RA'), hazT.has('RA'));

  // Ceiling thresholds (CIG)
  const cig = d.cigMin;
  const metCig = d.metCig;
  const tafCig = d.tafCig;
  if(cig != null){
    if(cig < 500){
      push('CIG<500', 'cig', (metCig != null && metCig < 500), (tafCig != null && tafCig < 500));
    }else if(cig < 1000){
      push('CIG<1000', 'cig', (metCig != null && metCig < 1000), (tafCig != null && tafCig < 1000));
    }
  }

  // Deduplicate by label
  const seen = new Set();
  const out = [];
  for(const x of tags){
    if(seen.has(x.t)) continue;
    seen.add(x.t);
    out.push(x);
  }

  // Always pin ENG ICE OPS at the front if present
  out.sort((a,b) => (a.key === 'eng' ? -1 : 0) - (b.key === 'eng' ? -1 : 0));
  return out;
}

function extractRvrValuesMeters(raw){
  if(!raw) return [];
  // Examples: R17/0600, R17L/0600U, R09/0400V0800, R27/P1500
  const re = /\bR\d{2}[LRC]?\/[PM]?\d{4}(?:V[PM]?\d{4})?[UDN]?\b/g;
  const tokens = raw.match(re) || [];
  const values = [];
  for(const tok of tokens){
    // Pull all 4-digit chunks after the slash and optional V
    const nums = tok.match(/\d{4}/g) || [];
    for(const n of nums){
      const v = parseInt(n, 10);
      if(Number.isFinite(v)) values.push(v);
    }
  }
  return values;
}

function computeRvrMin(item){
  const vals = [...extractRvrValuesMeters(item.metarRaw), ...extractRvrValuesMeters(item.tafRaw)];
  if(!vals.length) return null;
  return Math.min(...vals);
}

function rvrClassFromMin(v){
  if(v == null) return null;
  if(v <= 75) return 'hl-rvr-75';
  if(v <= 200) return 'hl-rvr-200';
  if(v <= 300) return 'hl-rvr-300';
  if(v <= 500) return 'hl-rvr-500';
  return null;
}

function parseSmToMeters(token){
  // Handles: 1/2SM, 2SM, 1 1/2SM (as two tokens typically), P6SM
  const t = token.toUpperCase();
  if(!t.endsWith('SM')) return null;
  if(t.startsWith('P')) return null; // greater than
  const core = t.slice(0, -2);
  // fraction a/b
  if(/^\d+\/\d+$/.test(core)){
    const [a,b] = core.split('/').map(x => parseInt(x,10));
    if(!b) return null;
    const miles = a / b;
    return miles * 1609.344;
  }
  // decimal / integer
  if(/^\d+(?:\.\d+)?$/.test(core)){
    const miles = parseFloat(core);
    if(!Number.isFinite(miles)) return null;
    return miles * 1609.344;
  }
  return null;
}

function visClassFromMeters(m){
  if(m == null) return null;
  if(m <= 150) return 'hl-vis-150';
  if(m <= 175) return 'hl-vis-175';
  if(m <= 250) return 'hl-vis-250';
  if(m <= 300) return 'hl-vis-300';
  if(m <= 500) return 'hl-vis-500';
  if(m <= 550) return 'hl-vis-550';
  if(m <= 800) return 'hl-vis-800';
  return null;
}

function lowVisLabelFromMeters(m){
  if(m == null) return null;
  if(m <= 150) return '≤150';
  if(m <= 175) return '≤175';
  if(m <= 250) return '≤250';
  if(m <= 300) return '≤300';
  if(m <= 500) return '≤500';
  if(m <= 550) return '≤550';
  if(m <= 800) return '≤800';
  return null;
}

function wxClassFromToken(token){
  const t0 = token.toUpperCase();
  const t = t0.replace(/^[-+]/, '');
  const t2 = t.startsWith('VC') ? t.slice(2) : t;

  // Thunderstorm first (e.g., -TSRA)
  if(/TS/.test(t2)) return 'hl-ts';

  // Fog / mist group
  if(/FZFG/.test(t2) || /\bFG\b/.test(t2) || t2 === 'BR' || /BR/.test(t2) || /MIFG|BCFG|PRFG|VCFG/.test(t2)) return 'hl-fog';

  // Snow / ice pellets
  if(/SN|SHSN|BLSN|DRSN|SG|PL/.test(t2)) return 'hl-snow';

  // Rain / drizzle / freezing
  if(/RA|SHRA|DZ|FZRA|FZDZ/.test(t2)) return 'hl-rain';

  return null;
}


function fmtVis(m){
  if(m == null) return '—';
  if(m >= 10000) return '10 km or more';
  if(m >= 1000) return `${(m/1000).toFixed(1)} km (${m} m)`;
  return `${m} m`;
}

function parseWind(raw){
  const m = (raw||'').match(/\b(\d{3}|VRB)(\d{2,3})(G(\d{2,3}))?KT\b/);
  if(!m) return null;
  const dir = m[1];
  const spd = parseInt(m[2],10);
  const gst = m[4] ? parseInt(m[4],10) : null;
  if(!Number.isFinite(spd)) return null;
  return { dir, spd, gst };
}

function parseTempDew(raw){
  const m = (raw||'').match(/\b(M?\d{2})\/(M?\d{2})\b/);
  if(!m) return null;
  const conv = (x) => {
    const neg = x.startsWith('M');
    const n = parseInt(neg ? x.slice(1) : x, 10);
    return neg ? -n : n;
  };
  return { tempC: conv(m[1]), dewC: conv(m[2]) };
}

function parseQnh(raw){
  const q = (raw||'').match(/\bQ(\d{4})\b/);
  if(q) return { hpa: parseInt(q[1],10) };
  const a = (raw||'').match(/\bA(\d{4})\b/);
  if(a){
    const inHg = parseInt(a[1],10) / 100;
    const hpa = Math.round(inHg * 33.8639);
    return { hpa, inHg };
  }
  return null;
}

function parseClouds(raw){
  const toks = String(raw||'').split(/\s+/).filter(Boolean);
  const out = [];
  for(const t0 of toks){
    const t = t0.toUpperCase();
    const m = t.match(/^(FEW|SCT|BKN|OVC|VV)(\d{3})(CB|TCU)?$/);
    if(m){
      const amount = m[1];
      const ft = parseInt(m[2],10) * 100;
      out.push({ amount, ft, type: m[3] || '' });
    }
  }
  out.sort((a,b)=>a.ft-b.ft);
  return out.length ? out : null;
}

function listWxFromHazards(hazSet){
  const labels = [];
  if(hazSet.has('FZFG')) labels.push('Freezing fog (FZFG)');
  if(hazSet.has('FG')) labels.push('Fog (FG)');
  if(hazSet.has('BR')) labels.push('Mist (BR)');
  if(hazSet.has('TS')) labels.push('Thunderstorm (TS)');
  if(hazSet.has('SN')) labels.push('Snow (SN)');
  if(hazSet.has('RA')) labels.push('Rain/Drizzle (RA/DZ)');
  return labels;
}

function decodeMetar(raw){
  if(!raw) return '<span class="muted">—</span>';
  const toks = String(raw).split(/\s+/).filter(Boolean);
  const haz = hazardsFromRaw(raw);

  const wind = parseWind(raw);
  const vis = visMinFromTokens(toks);
  const clouds = parseClouds(raw);
  const td = parseTempDew(raw);
  const qnh = parseQnh(raw);

  const lines = [];
  if(wind){
    lines.push(`Wind: ${wind.dir}° ${wind.spd} kt${wind.gst ? ` (gust ${wind.gst} kt)` : ''}`);
  }
  if(vis != null){
    lines.push(`Visibility: ${fmtVis(vis)}`);
  }
  const wx = listWxFromHazards(haz);
  if(wx.length){
    lines.push(`Weather: ${wx.join(', ')}`);
  }
  if(clouds){
    const c0 = clouds.map(c => `${c.amount} ${String(Math.round(c.ft/100)).padStart(3,'0')} (${c.ft} ft)${c.type ? ' '+c.type : ''}`).join(', ');
    lines.push(`Clouds: ${c0}`);
  }
  if(td){
    lines.push(`Temp/Dew point: ${td.tempC}°C / ${td.dewC}°C`);
  }
  if(qnh){
    lines.push(`QNH: ${qnh.hpa} hPa${qnh.inHg ? ` (${qnh.inHg.toFixed(2)} inHg)` : ''}`);
  }

  if(!lines.length) return '<span class="muted">No decodable elements.</span>';
  return `<ul class="decodedList">` + lines.map(x => `<li>${escapeHtml(x)}</li>`).join('') + `</ul>`;
}

function decodeTaf(raw){
  if(!raw) return '<span class="muted">—</span>';

  const toks = String(raw).split(/\s+/).filter(Boolean);
  const haz = hazardsFromRaw(raw);

  // Header: validity DDHH/DDHH
  const valid = raw.match(/\b(\d{4})\/(\d{4})\b/);
  const validTxt = valid ? `${valid[1]}–${valid[2]}Z` : null;

  // Identify change groups
  const groups = [];
  let cur = { title: 'BASE', tokens: [] };
  const isChange = (t) => /^(FM\d{6}|TEMPO|BECMG|PROB\d{2})$/.test(t) || /^PROB\d{2}$/.test(t);
  for(const t of toks){
    const up = t.toUpperCase();
    if(isChange(up) && cur.tokens.length){
      groups.push(cur);
      cur = { title: up, tokens: [] };
      continue;
    }
    cur.tokens.push(up);
  }
  if(cur.tokens.length) groups.push(cur);

  const summarize = (gtoks) => {
    const wind = parseWind(gtoks.join(' '));
    const vis = visMinFromTokens(gtoks);
    const clouds = parseClouds(gtoks.join(' '));
    const haz2 = hazardsFromRaw(gtoks.join(' '));
    const parts = [];
    if(wind) parts.push(`wind ${wind.dir}° ${wind.spd} kt${wind.gst ? ` gust ${wind.gst}` : ''}`);
    if(vis != null) parts.push(`vis ${fmtVis(vis)}`);
    const wx = listWxFromHazards(haz2);
    if(wx.length) parts.push(wx.map(x => x.replace(/\s*\([^)]*\)/g,'')).join(', ').toLowerCase());
    if(clouds){
      const cmin = clouds[0];
      parts.push(`cig ${cmin.ft} ft (${cmin.amount})`);
    }
    return parts.length ? parts.join(' · ') : '—';
  };

  const lines = [];
  if(validTxt) lines.push(`Validity: ${validTxt}`);
  const wx = listWxFromHazards(haz);
  if(wx.length) lines.push(`Weather signals: ${wx.join(', ')}`);

  // Add first 4 groups summaries
  const maxGroups = 4;
  const gLines = groups.slice(0, maxGroups).map(g => {
    const title = (g.title === 'BASE') ? 'Base' : g.title;
    return `${title}: ${summarize(g.tokens)}`;
  });
  if(groups.length > maxGroups) gLines.push(`(+${groups.length - maxGroups} more change groups)`);

  const all = lines.concat(gLines).filter(Boolean);
  return `<ul class="decodedList">` + all.map(x => `<li>${escapeHtml(x)}</li>`).join('') + `</ul>`;
}

function highlightRaw(raw, ctx = {}){
  // ctx: { engice: boolean }
  if(!raw) return '<span class="muted">—</span>';
  const parts = String(raw).split(/(\s+)/);
  return parts.map((p) => {
    if(!p) return '';
    if(/^\s+$/.test(p)) return p;

    // RVR tokens
    if(/^R\d{2}[LRC]?\/[PM]?\d{4}(?:V[PM]?\d{4})?[UDN]?$/i.test(p)){
      const nums = (p.match(/\d{4}/g) || []).map(x => parseInt(x,10)).filter(n => Number.isFinite(n));
      const minv = nums.length ? Math.min(...nums) : null;
      const cls = rvrClassFromMin(minv);
      if(cls){
        return `<span class="hl ${cls}" data-cat="rvr">${escapeHtml(p)}</span>`;
      }
      return escapeHtml(p);
    }


    // Visibility tokens in meters (4 digits)
    if(/^\d{4}$/.test(p)){
      const v = parseInt(p, 10);
      if(Number.isFinite(v)){
        const cls = visClassFromMeters(v);
        if(cls) return `<span class="hl ${cls}" data-cat="vis">${escapeHtml(p)}</span>`;
      }
      return escapeHtml(p);
    }


    // Ceiling tokens (METAR/TAF): highlight very low ceiling that drives CIG<500
    // (BKN/OVC/VV below 005 => <500 ft AGL)
    if(/^(BKN|OVC|VV)\d{3}$/i.test(p)){
      const n = parseInt(p.slice(-3), 10); // hundreds of feet
      if(Number.isFinite(n) && n < 5){
        return `<span class="hl hl-cig-500" data-cat="cig">${escapeHtml(p)}</span>`;
      }
    }

    // Visibility tokens in statute miles
    const sm = parseSmToMeters(p);
    if(sm != null){
      const cls = visClassFromMeters(sm);
      if(cls) return `<span class="hl ${cls}" data-cat="vis">${escapeHtml(p)}</span>`;
      return escapeHtml(p);
    }

    // Weather phenomena tokens
    if(ctx.engice && /FZFG/i.test(p)){
      return `<span class="hl hl-engice" data-cat="eng">${escapeHtml(p)}</span>`;
    }

    const wxCls = wxClassFromToken(p);
    if(wxCls){
      return `<span class="hl ${wxCls}" data-cat="wx">${escapeHtml(p)}</span>`;
    }

    return escapeHtml(p);
  }).join('');
}

function alertMatch(item, desired){
  if(!desired || desired === 'all') return true;
  const score = displayScore(item);
  const lbl = levelFromScore(score).label.toLowerCase();
  return lbl === desired;
}

function conditionMatch(item, cond){
  if(cond === 'all') return true;
  const hazards = Array.isArray(item.hazards) ? item.hazards : [];
  const d = item._d || derivePerStation(item);
  const worstVis = d.worstVis;
  const score = displayScore(item);
  const rvrMin = Number.isFinite(item.rvrMin) ? item.rvrMin : null;

  switch(cond){
    case 'alerts': return score >= 20;
    case 'engice': return hasEngineIcingStopFlag(item);
    case 'vis800': return worstVis != null && worstVis <= 800;
    case 'vis550': return worstVis != null && worstVis <= 550;
    case 'vis500': return worstVis != null && worstVis <= 500;
    case 'vis300': return worstVis != null && worstVis <= 300;
    case 'vis250': return worstVis != null && worstVis <= 250;
    case 'vis175': return worstVis != null && worstVis <= 175;
    case 'vis150': return worstVis != null && worstVis <= 150;
    case 'rvr500': return rvrMin != null && rvrMin <= 500;
    case 'rvr300': return rvrMin != null && rvrMin <= 300;
    case 'rvr200': return rvrMin != null && rvrMin <= 200;
    case 'rvr75':  return rvrMin != null && rvrMin <= 75;
    case 'fog': return hazards.includes('FG') || hazards.includes('BR') || hazards.includes('FZFG');
    case 'snow': return hazards.some(h => ['SN','SHSN','BLSN','PL','SG'].includes(h));
    case 'rain': return hazards.some(h => ['RA','+RA','SHRA','DZ','FZDZ','FZRA'].includes(h));
    case 'ts': return hazards.some(h => /^TS/.test(h));
    default: return true;
  }
}

function renderSrc(t){
  // Renders small origin badges inside trigger tags (M=METAR, T=TAF)
  if(!t || (!t.srcM && !t.srcT)) return '';
  const m = t.srcM ? '<span class="src src--m" title="Triggered by METAR">M</span>' : '';
  const tt = t.srcT ? '<span class="src src--t" title="Triggered by TAF">T</span>' : '';
  return `<span class="srcWrap">${m}${tt}</span>`;
}

function renderRow(item, nowIso){
  const icao = escapeHtml(item.icao);
  const iata = item.iata ? escapeHtml(item.iata) : '';
  const name = item.name ? escapeHtml(item.name) : '';

  const score = displayScore(item);
  const lvl = levelFromScore(score);

  const metarAge = ageMinutes(item.metarRaw, nowIso);
  const tafAge = ageMinutes(item.tafRaw, nowIso);

  // Table VIS shows METAR visibility in meters (as in your reference screenshot).
  const visM = visNumber(item.visibility_m ?? null);
  const prevVis = (state.prevVis && state.prevVis[item.icao] != null) ? Number(state.prevVis[item.icao]) : null;
  const deltaVis = (visM != null && prevVis != null && Number.isFinite(prevVis)) ? (visM - prevVis) : null;
  let trendPill = '';
  if(visM != null){
    if(prevVis == null || !Number.isFinite(prevVis)){
      trendPill = `<span class="trendPill trendPill--new" title="No previous sample">NEW</span>`;
    }else if(deltaVis > 0){
      trendPill = `<span class="trendPill trendPill--up" title="+${escapeHtml(String(deltaVis))} m">▲${escapeHtml(String(deltaVis))}</span>`;
    }else if(deltaVis < 0){
      trendPill = `<span class="trendPill trendPill--down" title="${escapeHtml(String(deltaVis))} m">▼${escapeHtml(String(Math.abs(deltaVis)))}</span>`;
    }else{
      trendPill = `<span class="trendPill trendPill--flat" title="0 m">•0</span>`;
    }
  }
  const d = item._d || derivePerStation(item);
  const worstVis = d.worstVis;
  const lowVisLabel = lowVisLabelFromMeters(worstVis);
  const lowVisCls = visClassFromMeters(worstVis);

  const triggers = buildTriggers(item);
  const engice = hasEngineIcingStopFlag(item);

  return `
    <tr class="row" data-icao="${icao}">
      <td>
        <div class="airport">
          <div class="airport__codes">
            <span class="airport__icao mono">${icao}</span>
            ${iata ? `<span class="airport__iata mono">${iata}</span>` : ''}
            <button class="openBtn" type="button" title="Open Quick View" aria-label="Open Quick View">›</button>
          </div>
          ${name ? `<div class="airport__name">${name}</div>` : ''}
        </div>
      </td>

      <td><span class="${lvl.cls}">${lvl.label}</span></td>

      <td class="mono"><span class="num">${visM == null ? '—' : visM}</span>${trendPill ? ` ${trendPill}` : ''}</td>

      <td>${lowVisLabel ? `<span class="hl ${lowVisCls}" data-cat="vis">VIS${lowVisLabel}</span>` : '<span class="muted">—</span>'}</td>

      <td>
        <div class="triggers">
          ${triggers.length
            ? triggers.map(t => {
              const k = (t.key || 'wx');
              const cat = k.startsWith('vis') ? 'vis' : (k.startsWith('rvr') ? 'rvr' : (k === 'cig' ? 'cig' : k));
              return `<span class="tag tag--${cat}">${escapeHtml(t.t)}${renderSrc(t)}</span>`;
            }).join('')
            : `<span class="muted">—</span>`
          }
        </div>
      </td>

      <td>${metarAge == null ? '<span class="muted">—</span>' : `<span class="${metarAge <= 20 ? 'age age--fresh' : (metarAge <= 60 ? 'age age--warn' : 'age age--stale')}">${metarAge}m</span>`}</td>
      <td>${tafAge == null ? '<span class="muted">—</span>' : `<span class="${tafAge <= 60 ? 'age age--fresh' : (tafAge <= 180 ? 'age age--warn' : 'age age--stale')}">${tafAge}m</span>`}</td>

      <td><div class="raw">${item.metarRaw ? highlightRaw(item.metarRaw, { engice }) : '<span class="muted">No METAR</span>'}</div></td>
      <td><div class="raw">${item.tafRaw ? highlightRaw(item.tafRaw, { engice }) : '<span class="muted">No TAF</span>'}</div></td>
    </tr>
  `;
}

let state = {
  generatedAt: null,
  stations: [],
  stats: null,
  errors: [],
};

// Local persistence for simple trend indicators (client-side only).
const LS_KEY_VIS = 'wzz_prev_vis_v1';

function loadPrevVis(){
  try{
    const raw = localStorage.getItem(LS_KEY_VIS);
    if(!raw) return {};
    const obj = JSON.parse(raw);
    return (obj && typeof obj === 'object') ? obj : {};
  }catch(_e){
    return {};
  }
}

function savePrevVis(map){
  try{
    localStorage.setItem(LS_KEY_VIS, JSON.stringify(map || {}));
  }catch(_e){
    // ignore
  }
}

// Initialize trend baseline
state.prevVis = loadPrevVis();
state.drawerItem = null;

// Drawer helpers
function openDrawer(item){
  if(!item) return;
  const drawer = byId('drawer');
  if(!drawer) return;

  state.drawerItem = item;

  const title = byId('dTitle');
  const sub = byId('dSub');
  const sum = byId('dSummary');
  const met = byId('dMetar');
  const taf = byId('dTaf');
  const metDec = byId('dMetarDecoded');
  const tafDec = byId('dTafDecoded');

  const icao = item.icao || '—';
  const iata = item.iata || '';
  const name = item.name || '';

  const score = displayScore(item);
  const lvl = levelFromScore(score);

  const nowIso = new Date().toISOString();
  const metAge = ageMinutes(item.metarRaw, nowIso);
  const tafAge = ageMinutes(item.tafRaw, nowIso);

  const vis = visNumber(item.visibility_m ?? null);
  const d = item._d || derivePerStation(item);
  const worstVis = d.worstVis;
  const rvrMin = Number.isFinite(item.rvrMin) ? item.rvrMin : null;
  const cig = (item.ceiling_ft != null) ? item.ceiling_ft : null;

  const trigs = buildTriggers(item);

  if(title) title.textContent = `${icao}${iata ? '  •  ' + iata : ''}`;
  if(sub) sub.textContent = name ? name : '—';

  const mkAge = (x) => (x == null ? '—' : `${x}m`);
  const mkNum = (x, suf='') => (x == null ? '—' : `${x}${suf}`);

  if(sum){
    sum.innerHTML = [
      `<div class="kv"><div class="kv__k">Alert</div><div class="kv__v"><span class="${lvl.cls}">${lvl.label}</span></div></div>`,
      `<div class="kv"><div class="kv__k">Severity</div><div class="kv__v mono">${score}</div></div>`,
      `<div class="kv"><div class="kv__k">Visibility</div><div class="kv__v mono">${mkNum(vis,' m')}</div></div>`,
      `<div class="kv"><div class="kv__k">Worst VIS (METAR/TAF)</div><div class="kv__v mono">${mkNum(worstVis,' m')}</div></div>`,
      `<div class="kv"><div class="kv__k">RVR (min)</div><div class="kv__v mono">${mkNum(rvrMin,' m')}</div></div>`,
      `<div class="kv"><div class="kv__k">Ceiling</div><div class="kv__v mono">${mkNum(cig,' ft')}</div></div>`,
      `<div class="kv"><div class="kv__k">METAR age</div><div class="kv__v mono">${mkAge(metAge)}</div></div>`,
      `<div class="kv"><div class="kv__k">TAF age</div><div class="kv__v mono">${mkAge(tafAge)}</div></div>`,
      `<div class="kv" style="grid-column:1 / -1;"><div class="kv__k">Triggers</div><div class="kv__v">${trigs.length ? trigs.map(t => {
        const k = (t.key || 'wx');
        const cat = k.startsWith('vis') ? 'vis' : (k.startsWith('rvr') ? 'rvr' : (k === 'cig' ? 'cig' : k));
        return `<span class="tag tag--${cat}">${escapeHtml(t.t)}${renderSrc(t)}</span>`;
      }).join(' ') : '<span class="muted">—</span>'}</div></div>`,
    ].join('');
  }

  const engice = hasEngineIcingStopFlag(item);
  if(met) met.innerHTML = item.metarRaw ? highlightRaw(item.metarRaw, { engice }) : '<span class="muted">No METAR</span>';
  if(taf) taf.innerHTML = item.tafRaw ? highlightRaw(item.tafRaw, { engice }) : '<span class="muted">No TAF</span>';

  if(metDec) metDec.innerHTML = decodeMetar(item.metarRaw);
  if(tafDec) tafDec.innerHTML = decodeTaf(item.tafRaw);

  drawer.classList.add('is-open');
  drawer.setAttribute('aria-hidden', 'false');
}

function closeDrawer(){
  const drawer = byId('drawer');
  if(!drawer) return;
  drawer.classList.remove('is-open');
  drawer.setAttribute('aria-hidden', 'true');
}

function updateCriticalBarFromDom(){
  const tbody = $('#tbody');
  if(!tbody) return;
  const trs = Array.from(tbody.querySelectorAll('tr[data-icao]'));
  const hasTagText = (tr, txt) => {
    const tags = tr.querySelectorAll('.tag');
    for(const t of tags){ if((t.textContent || '').trim() === txt) return true; }
    return false;
  };

  const engRows = trs.filter(tr => tr.querySelector('.tag--eng') || hasTagText(tr, 'ENG ICE OPS'));
  const eng = engRows.length;
  const crit = trs.filter(tr => tr.querySelector('.pill--crit')).length;
  const vis175 = trs.filter(tr => {
    const tags = Array.from(tr.querySelectorAll('.tag--vis'));
    return tags.some(t => /^VIS≤(150|175)$/.test((t.textContent||'').trim()));
  }).length;
  const ts = trs.filter(tr => tr.querySelector('.tag--ts') || hasTagText(tr, 'TS')).length;

  const set = (id, val) => { const el = $('#' + id); if(el) el.textContent = String(val); };
  set('cbEngCount', eng);
  set('cbCritCount', crit);
  set('cbVis175Count', vis175);
  set('cbTsCount', ts);

  // ENG ICE OPS: show affected IATA codes (big)
  const iatas = [];
  for(const tr of engRows){
    const iataEl = tr.querySelector('.airport__iata');
    const icaoEl = tr.querySelector('.airport__icao');
    const code = (iataEl?.textContent || '').trim() || (icaoEl?.textContent || '').trim();
    if(code) iatas.push(code.toUpperCase());
  }
  const uniq = Array.from(new Set(iatas));
  const maxShow = 10;
  const shown = uniq.slice(0, maxShow);
  const more = uniq.length - shown.length;
  const el = byId('cbEngIatas');
  if(el){
    el.textContent = shown.join(' ') + (more > 0 ? ` +${more}` : '');
  }
}


function applyFilters(){
  const text = ($('#filterText').value || '').trim().toUpperCase();
  const cond = $('#condSel').value;
  const alertSel = ($('#alertSel') ? $('#alertSel').value : 'all');
  const sortPriority = $('#sortPriority').checked;

  let rows = state.stations.slice();

  if(text){
    rows = rows.filter(s => {
      const hay = [s.icao, s.iata, s.name].filter(Boolean).join(' ').toUpperCase();
      return hay.includes(text);
    });
  }

  rows = rows.filter(s => conditionMatch(s, cond));
  rows = rows.filter(s => alertMatch(s, alertSel));

  if(sortPriority){
    rows.sort((a,b) => {
      const ae = hasEngineIcingStopFlag(a);
      const be = hasEngineIcingStopFlag(b);
      // Engine icing stop-flag is always pinned to the very top.
      if(ae && !be) return -1;
      if(!ae && be) return 1;
      return (displayScore(b) - displayScore(a)) || String(a.icao).localeCompare(String(b.icao));
    });
  }else{
    rows.sort((a,b) => String(a.icao).localeCompare(String(b.icao)));
  }

  return rows;
}

function render(){
  const tbody = $('#tbody');
  const msg = $('#statusMsg');
  const diag = $('#diag');

  // Recompute ages against current time even if the underlying JSON did not change.
  const nowIso = new Date().toISOString();

  const rows = applyFilters();

  // NOTE: Critical Bar counters are updated after table HTML is rendered (DOM-based),
  // so they always reflect exactly what you see on screen.
  const sc = $('#stationsCount'); if(sc) sc.textContent = String((state.stations||[]).length);

  // Prepare trend persistence for next render
  const nextVisMap = {};
  state.stations.forEach(s => {
    const v = visNumber(s.visibility_m ?? null);
    if(v != null) nextVisMap[s.icao] = v;
  });

  // Status + diagnostics
  const stats = state.stats || null;
  const errList = Array.isArray(state.errors) ? state.errors : [];

  if(stats && (Object.keys(stats).length || errList.length)){
    const parts = [];
    if(stats.icaoCount != null) parts.push(`<b>ICAO</b>: <span class="mono">${escapeHtml(String(stats.icaoCount))}</span>`);
    if(stats.metarReturned != null) parts.push(`<b>METAR</b>: <span class="mono">${escapeHtml(String(stats.metarReturned))}</span>`);
    if(stats.tafReturned != null) parts.push(`<b>TAF</b>: <span class="mono">${escapeHtml(String(stats.tafReturned))}</span>`);
    if(stats.missingMetar != null) parts.push(`<b>Missing METAR</b>: <span class="mono">${escapeHtml(String(stats.missingMetar))}</span>`);
    if(stats.missingTaf != null) parts.push(`<b>Missing TAF</b>: <span class="mono">${escapeHtml(String(stats.missingTaf))}</span>`);

    let html = parts.join(' &nbsp; | &nbsp; ');
    if(errList.length){
      html += `<div style="margin-top:6px" class="err"><b>Errors</b>: ${escapeHtml(errList.join(' | '))}</div>`;
    }
    diag.hidden = false;
    diag.innerHTML = html;
  }else{
    diag.hidden = true;
    diag.innerHTML = '';
  }

  if(state.stations.length === 0){
    msg.textContent = '0 stations loaded. This usually means the GitHub Action did not generate data/latest.json yet (or could not push). Open data/status.json in the repo for the exact error, and ensure you have a workflow under .github/workflows and Actions has Read & write permissions.';
  }else{
    msg.textContent = '';
  }

  tbody.innerHTML = rows.length
    ? rows.map(r => renderRow(r, nowIso)).join('')
    : '<tr><td colspan="9" class="muted">No matching rows.</td></tr>';

  // Update critical tiles now that the visible rows exist.
  updateCriticalBarFromDom();
  // Extra safety: in some browsers innerHTML updates may render on next frame.
  requestAnimationFrame(updateCriticalBarFromDom);

  // Persist baseline for VIS trend arrows
  savePrevVis(nextVisMap);
  state.prevVis = nextVisMap;
}

async function load(){
  const tbody = $('#tbody');
  try{
    // Load main data
    const res = await fetch(`${DATA_URL}?t=${Date.now()}`, { cache: 'no-store' });
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();

    state.generatedAt = data.generatedAt || null;
    state.stations = Array.isArray(data.stations) ? data.stations.map((s) => {
      const d = derivePerStation(s);
      return {
        ...s,
        rvrMin: d.rvrMin,
        _d: d,
        _engIceM: d.engIceM,
        _engIceT: d.engIceT,
      };
    }) : [];
    state.stats = data.stats || null;
    state.errors = Array.isArray(data.errors) ? data.errors : [];

    // Also try to load status.json (more reliable diagnostics if latest.json stayed as placeholder)
    try{
      const sres = await fetch(`${STATUS_URL}?t=${Date.now()}`, { cache: 'no-store' });
      if(sres.ok){
        const sdata = await sres.json();
        if(!state.stats && sdata.stats) state.stats = sdata.stats;
        if((!state.errors || !state.errors.length) && Array.isArray(sdata.errors)) state.errors = sdata.errors;
      }
    }catch{ /* ignore */ }

    $('#lastUpdate').textContent = formatGeneratedAt(state.generatedAt);
    const sc = $('#stationsCount');
    if(sc) sc.textContent = String((state.stations||[]).length);

    render();
  }catch(e){
    tbody.innerHTML = `<tr><td colspan="9" class="muted">Data load error: ${escapeHtml(String(e))}</td></tr>`;
  }
}

let timer = null;
function startTimer(){
  stopTimer();
  timer = setInterval(load, REFRESH_MS);
}
function stopTimer(){
  if(timer) clearInterval(timer);
  timer = null;
}

// Wire UI
$('#refreshBtn').addEventListener('click', () => load());
$('#autoRefresh').addEventListener('change', (e) => e.target.checked ? startTimer() : stopTimer());

['filterText','condSel','alertSel','sortPriority'].forEach(id => {
  const el = $('#' + id);
  if(!el) return;
  el.addEventListener('input', render);
  el.addEventListener('change', render);
});

// Critical Bar quick filters
function setFilters(opts){
  const o = opts || {};
  const ft = $('#filterText'); if(ft && o.text != null) ft.value = o.text;
  const cs = $('#condSel'); if(cs && o.cond != null) cs.value = o.cond;
  const al = $('#alertSel'); if(al && o.alert != null) al.value = o.alert;
  const sp = $('#sortPriority'); if(sp && o.sort != null) sp.checked = !!o.sort;
  render();
}

(function(){
  const el = $('#cbEng'); if(el) el.addEventListener('click', () => setFilters({ cond: 'engice', alert: 'all', sort: true }));
})();
(function(){
  const el = $('#cbCrit'); if(el) el.addEventListener('click', () => setFilters({ cond: 'all', alert: 'crit', sort: true }));
})();
(function(){
  const el = $('#cbVis175'); if(el) el.addEventListener('click', () => setFilters({ cond: 'vis175', alert: 'all', sort: true }));
})();
(function(){
  const el = $('#cbTs'); if(el) el.addEventListener('click', () => setFilters({ cond: 'ts', alert: 'all', sort: true }));
})();
(function(){
  const el = $('#cbReset'); if(el) el.addEventListener('click', () => setFilters({ text: '', cond: 'all', alert: 'all', sort: true }));
})();

// Row click -> drawer
(function(){
  const tb = $('#tbody');
  if(!tb) return;
  tb.addEventListener('click', (e) => {
    const tr = e.target.closest('tr[data-icao]');
    if(!tr) return;
    const icao = tr.getAttribute('data-icao');
    const item = (state.stations || []).find(s => s.icao === icao);
    openDrawer(item);
  });
})();

// Drawer close actions
(function(){
  const x = byId('drawerClose'); if(x) x.addEventListener('click', closeDrawer);
  const b = byId('drawerBackdrop'); if(b) b.addEventListener('click', closeDrawer);
})();
document.addEventListener('keydown', (e) => { if(e.key === 'Escape') closeDrawer(); });

// Copy briefing line
(function(){
  const btn = $('#copyBrief');
  if(!btn) return;
  btn.addEventListener('click', async () => {
    const item = state.drawerItem;
    if(!item) return;

    const nowIso = new Date().toISOString();
    const score = displayScore(item);
    const lvl = levelFromScore(score);
    const vis = visNumber(item.visibility_m ?? null);
    const d = item._d || derivePerStation(item);
  const worstVis = d.worstVis;
    const rvrMin = Number.isFinite(item.rvrMin) ? item.rvrMin : null;
    const cig = (item.ceiling_ft != null) ? item.ceiling_ft : null;
    const metAge = ageMinutes(item.metarRaw, nowIso);
    const tafAge = ageMinutes(item.tafRaw, nowIso);

    const trigs = buildTriggers(item).map(t => t.t).join(', ');
    const line = [
      `${item.icao}${item.iata ? `(${item.iata})` : ''}`,
      `ALERT=${lvl.label}`,
      `SCORE=${score}`,
      `VIS=${vis != null ? vis+'m' : '—'}`,
      `WVIS=${worstVis != null ? worstVis+'m' : '—'}`,
      `RVRmin=${rvrMin != null ? rvrMin+'m' : '—'}`,
      `CIG=${cig != null ? cig+'ft' : '—'}`,
      `METARage=${metAge != null ? metAge+'m' : '—'}`,
      `TAFage=${tafAge != null ? tafAge+'m' : '—'}`,
      trigs ? `TRIG=${trigs}` : ''
    ].filter(Boolean).join(' | ');

    try{
      await navigator.clipboard.writeText(line);
      const msg = $('#statusMsg');
      if(msg){
        msg.textContent = 'Briefing line copied to clipboard.';
        setTimeout(() => { if(msg.textContent === 'Briefing line copied to clipboard.') msg.textContent = ''; }, 1800);
      }
    }catch(_e){
      const ta = document.createElement('textarea');
      ta.value = line;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
    }
  });
})();


load();
startTimer();

// Keep the “age” columns current even between 10‑minute data refreshes.
setInterval(() => {
  if(state && Array.isArray(state.stations) && state.stations.length) render();
}, 60 * 1000);