/*
  Front-end renderer for data/latest.json (generated by GitHub Actions).

  UX goals (based on your reference screenshot):
  - compact status table
  - filter bar (ICAO/IATA/name)
  - “All conditions” selector
  - “Sort by priority” toggle
  - explicit columns (Alert / VIS / flags / triggers / ages / raw)
*/

const DATA_URL = 'data/latest.json';
const dataUrl = () => `${DATA_URL}?ts=${Date.now()}`;
const STATUS_URL = 'data/status.json';
const REFRESH_MS = 10 * 60 * 1000;

const $ = (sel) => document.querySelector(sel);

function escapeHtml(s){
  return (s ?? '').replace(/[&<>"']/g, (c) => ({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
  }[c]));
}

function formatGeneratedAt(s){
  if(!s) return '—';
  const t = Date.parse(s);
  if(Number.isNaN(t)) return '—';
  return new Date(t).toLocaleString();
}


function clamp(n, a, b){
  return Math.max(a, Math.min(b, n));
}

function levelFromScore(score){
  if (score >= 70) return { label: 'CRIT', cls: 'pill pill--crit' };
  if (score >= 45) return { label: 'HIGH', cls: 'pill pill--high' };
  if (score >= 20) return { label: 'MED',  cls: 'pill pill--med' };
  return { label: 'OK',   cls: 'pill pill--ok' };
}

function parseDdhhmmZ(raw){
  // Finds the first DDHHMMZ group.
  if (!raw) return null;
  const m = raw.match(/\b(\d{2})(\d{2})(\d{2})Z\b/);
  if(!m) return null;
  return { dd: Number(m[1]), hh: Number(m[2]), mm: Number(m[3]) };
}

function obsTimeUtcFromGroup(ddhhmm, baseIso){
  // METAR/TAF has day-of-month (DD) without month/year.
  // Build a UTC Date close to base by trying month-1, month, month+1 and picking the closest.
  if(!ddhhmm || !baseIso) return null;
  const base = new Date(baseIso);
  if(Number.isNaN(base.getTime())) return null;

  const y = base.getUTCFullYear();
  const m = base.getUTCMonth();
  const candidates = [m-1, m, m+1].map(mm => {
    const d = new Date(Date.UTC(y, mm, ddhhmm.dd, ddhhmm.hh, ddhhmm.mm, 0));
    return d;
  });
  let best = candidates[0];
  let bestAbs = Math.abs(best.getTime() - base.getTime());
  for(const c of candidates.slice(1)){
    const abs = Math.abs(c.getTime() - base.getTime());
    if(abs < bestAbs){ best = c; bestAbs = abs; }
  }
  return best;
}

function ageMinutes(raw, baseIso){
  // “How many minutes ago was it issued/observed” (relative to *now* by default).
  const g = new Date(baseIso);
  if(Number.isNaN(g.getTime())) return null;
  const group = parseDdhhmmZ(raw);
  const t = obsTimeUtcFromGroup(group, baseIso);
  if(!t) return null;
  const mins = Math.round((g.getTime() - t.getTime()) / 60000);
  if(!Number.isFinite(mins)) return null;
  // If something is weird (e.g. older than ~2 days), still show but clamp negatives.
  return clamp(mins, 0, 9999);
}

function visNumber(m){
  if(m == null) return null;
  if(m === 9999) return 10000;
  return m;
}

function buildTriggers(item){
  const tags = [];
  const hazards = Array.isArray(item.hazards) ? item.hazards : [];
  const has = (x) => hazards.includes(x);

  // RVR (minimum across METAR + TAF if available)
  const rvrMin = Number.isFinite(item.rvrMin) ? item.rvrMin : null;
  if(rvrMin != null){
    if(rvrMin <= 75) tags.push({ t: 'RVR≤75', key: 'rvr75' });
    else if(rvrMin <= 200) tags.push({ t: 'RVR≤200', key: 'rvr200' });
    else if(rvrMin <= 300) tags.push({ t: 'RVR≤300', key: 'rvr300' });
    else if(rvrMin <= 500) tags.push({ t: 'RVR≤500', key: 'rvr500' });
  }

  const worstVis = item.worst_visibility_m ?? item.visibility_m ?? null;
  const vis = visNumber(worstVis);

  if(vis != null){
    if(vis <= 150) tags.push({ t: 'VIS≤150', key: 'vis150' });
    else if(vis <= 175) tags.push({ t: 'VIS≤175', key: 'vis175' });
    else if(vis <= 250) tags.push({ t: 'VIS≤250', key: 'vis250' });
    else if(vis <= 300) tags.push({ t: 'VIS≤300', key: 'vis300' });
    else if(vis <= 500) tags.push({ t: 'VIS≤500', key: 'vis500' });
    else if(vis <= 550) tags.push({ t: 'VIS≤550', key: 'vis550' });
    else if(vis <= 800) tags.push({ t: 'VIS≤800', key: 'vis800' });
  }

  if(has('FZFG')) tags.push({ t: 'FZFG', key: 'fzfg' });

  // Fog / mist
  if(has('FG') || has('BR')) tags.push({ t: has('FG') ? 'FG' : 'BR', key: 'fog' });

  // TS group
  if(hazards.some(h => /^TS/.test(h))) tags.push({ t: 'TS', key: 'ts' });

  // Snow group
  if(hazards.some(h => ['SN','SHSN','BLSN','PL','SG'].includes(h))) tags.push({ t: 'SN', key: 'snow' });

  // Rain group
  if(hazards.some(h => ['RA','+RA','SHRA','DZ','FZDZ','FZRA'].includes(h))) tags.push({ t: 'RA', key: 'rain' });

  // Low ceiling (METAR only from server calc)
  if(item.ceiling_ft != null){
    if(item.ceiling_ft < 500) tags.push({ t: 'CIG<500', key: 'cig500' });
    else if(item.ceiling_ft < 1000) tags.push({ t: 'CIG<1000', key: 'cig1000' });
  }

  // Deduplicate by key
  const seen = new Set();
  return tags.filter(x => (seen.has(x.t) ? false : (seen.add(x.t), true)));
}


function tagClass(t){
  const k = t && t.key ? String(t.key) : '';
  const txt = t && t.t ? String(t.t) : '';

  if(k === 'cig500' || txt === 'CIG<500') return 'tag--cig500';
  if(k === 'cig1000' || txt === 'CIG<1000') return 'tag--cig1000';

  if(k.startsWith('rvr')) return 'tag--rvr';
  if(k.startsWith('vis')) return 'tag--vis';
  if(['fzfg','fog','ts','snow','rain'].includes(k)) return `tag--${k}`;

  return '';
}

function tagCat(t){
  const k = t && t.key ? String(t.key) : '';
  if(k.startsWith('rvr')) return 'rvr';
  if(k.startsWith('vis')) return 'vis';
  if(k.startsWith('cig')) return 'cig';
  return 'wx';
}

function extractRvrValuesMeters(raw){
  if(!raw) return [];
  // Examples: R17/0600, R17L/0600U, R09/0400V0800, R27/P1500
  const re = /\bR\d{2}[LRC]?\/[PM]?\d{4}(?:V[PM]?\d{4})?[UDN]?\b/g;
  const tokens = raw.match(re) || [];
  const values = [];
  for(const tok of tokens){
    // Pull all 4-digit chunks after the slash and optional V
    const nums = tok.match(/\d{4}/g) || [];
    for(const n of nums){
      const v = parseInt(n, 10);
      if(Number.isFinite(v)) values.push(v);
    }
  }
  return values;
}

function computeRvrMin(item){
  const vals = [...extractRvrValuesMeters(item.metarRaw), ...extractRvrValuesMeters(item.tafRaw)];
  if(!vals.length) return null;
  return Math.min(...vals);
}

function rvrClassFromMin(v){
  if(v == null) return null;
  if(v <= 75) return 'hl-rvr-75';
  if(v <= 200) return 'hl-rvr-200';
  if(v <= 300) return 'hl-rvr-300';
  if(v <= 500) return 'hl-rvr-500';
  return null;
}

function parseSmToMeters(token){
  // Handles: 1/2SM, 2SM, 1 1/2SM (as two tokens typically), P6SM
  const t = token.toUpperCase();
  if(!t.endsWith('SM')) return null;
  if(t.startsWith('P')) return null; // greater than
  const core = t.slice(0, -2);
  // fraction a/b
  if(/^\d+\/\d+$/.test(core)){
    const [a,b] = core.split('/').map(x => parseInt(x,10));
    if(!b) return null;
    const miles = a / b;
    return miles * 1609.344;
  }
  // decimal / integer
  if(/^\d+(?:\.\d+)?$/.test(core)){
    const miles = parseFloat(core);
    if(!Number.isFinite(miles)) return null;
    return miles * 1609.344;
  }
  return null;
}

function visClassFromMeters(m){
  if(m == null) return null;
  if(m <= 150) return 'hl-vis-150';
  if(m <= 175) return 'hl-vis-175';
  if(m <= 250) return 'hl-vis-250';
  if(m <= 300) return 'hl-vis-300';
  if(m <= 500) return 'hl-vis-500';
  if(m <= 550) return 'hl-vis-550';
  if(m <= 800) return 'hl-vis-800';
  return null;
}

function lowVisLabelFromMeters(m){
  if(m == null) return null;
  if(m <= 150) return '≤150';
  if(m <= 175) return '≤175';
  if(m <= 250) return '≤250';
  if(m <= 300) return '≤300';
  if(m <= 500) return '≤500';
  if(m <= 550) return '≤550';
  if(m <= 800) return '≤800';
  return null;
}

function wxClassFromToken(token){
  const t0 = token.toUpperCase();
  const t = t0.replace(/^[-+]/, '');
  const t2 = t.startsWith('VC') ? t.slice(2) : t;

  // Thunderstorm first (e.g., -TSRA)
  if(/TS/.test(t2)) return 'hl-ts';

  // Fog / mist group
  if(/FZFG/.test(t2) || /\bFG\b/.test(t2) || t2 === 'BR' || /BR/.test(t2) || /MIFG|BCFG|PRFG|VCFG/.test(t2)) return 'hl-fog';

  // Snow / ice pellets
  if(/SN|SHSN|BLSN|DRSN|SG|PL/.test(t2)) return 'hl-snow';

  // Rain / drizzle / freezing
  if(/RA|SHRA|DZ|FZRA|FZDZ/.test(t2)) return 'hl-rain';

  return null;
}

function highlightRaw(raw){
  if(!raw) return '<span class="muted">—</span>';
  const parts = String(raw).split(/(\s+)/);
  return parts.map((p) => {
    if(!p) return '';
    if(/^\s+$/.test(p)) return p;

    // RVR tokens
    if(/^R\d{2}[LRC]?\/[PM]?\d{4}(?:V[PM]?\d{4})?[UDN]?$/i.test(p)){
      const nums = (p.match(/\d{4}/g) || []).map(x => parseInt(x,10)).filter(n => Number.isFinite(n));
      const minv = nums.length ? Math.min(...nums) : null;
      const cls = rvrClassFromMin(minv);
      if(cls){
        return `<span class="hl ${cls}" data-cat="rvr">${escapeHtml(p)}</span>`;
      }
      return escapeHtml(p);
    }

    // Visibility tokens in meters (4 digits)
    if(/^\d{4}$/.test(p)){
      const v = parseInt(p, 10);
      if(Number.isFinite(v)){
        const cls = visClassFromMeters(v);
        if(cls) return `<span class="hl ${cls}" data-cat="vis">${escapeHtml(p)}</span>`;
      }
      return escapeHtml(p);
    }

    // Visibility tokens in statute miles
    const sm = parseSmToMeters(p);
    if(sm != null){
      const cls = visClassFromMeters(sm);
      if(cls) return `<span class="hl ${cls}" data-cat="vis">${escapeHtml(p)}</span>`;
      return escapeHtml(p);
    }

    // Ceiling tokens (BKN/OVC/VV)
    const cig = p.match(/^(BKN|OVC|VV)(\d{3})$/i);
    if(cig){
      const hundreds = parseInt(cig[2], 10);
      if(Number.isFinite(hundreds)){
        const feet = hundreds * 100;
        if(feet <= 500){
          return `<span class="hl hl-cig-500" data-cat="cig">${escapeHtml(p)}</span>`;
        }
        if(feet <= 1000){
          return `<span class="hl hl-cig-1000" data-cat="cig">${escapeHtml(p)}</span>`;
        }
      }
      return escapeHtml(p);
    }


    // Weather phenomena tokens
    const wxCls = wxClassFromToken(p);
    if(wxCls){
      return `<span class="hl ${wxCls}" data-cat="wx">${escapeHtml(p)}</span>`;
    }

    return escapeHtml(p);
  }).join('');
}

function alertMatch(item, desired){
  if(!desired || desired === 'all') return true;
  const score = Math.round(item.severityScore ?? 0);
  const lbl = levelFromScore(score).label.toLowerCase();
  return lbl === desired;
}

function conditionMatch(item, cond){
  if(cond === 'all') return true;
  const hazards = Array.isArray(item.hazards) ? item.hazards : [];
  const worstVis = visNumber(item.worst_visibility_m ?? item.visibility_m ?? null);
  const score = item.severityScore ?? 0;
  const rvrMin = Number.isFinite(item.rvrMin) ? item.rvrMin : null;

  switch(cond){
    case 'alerts': return score >= 20;
    case 'vis800': return worstVis != null && worstVis <= 800;
    case 'vis550': return worstVis != null && worstVis <= 550;
    case 'vis500': return worstVis != null && worstVis <= 500;
    case 'vis300': return worstVis != null && worstVis <= 300;
    case 'vis250': return worstVis != null && worstVis <= 250;
    case 'vis175': return worstVis != null && worstVis <= 175;
    case 'vis150': return worstVis != null && worstVis <= 150;
    case 'rvr500': return rvrMin != null && rvrMin <= 500;
    case 'rvr300': return rvrMin != null && rvrMin <= 300;
    case 'rvr200': return rvrMin != null && rvrMin <= 200;
    case 'rvr75':  return rvrMin != null && rvrMin <= 75;
    case 'fog': return hazards.includes('FG') || hazards.includes('BR') || hazards.includes('FZFG');
    case 'snow': return hazards.some(h => ['SN','SHSN','BLSN','PL','SG'].includes(h));
    case 'rain': return hazards.some(h => ['RA','+RA','SHRA','DZ','FZDZ','FZRA'].includes(h));
    case 'ts': return hazards.some(h => /^TS/.test(h));
    default: return true;
  }
}

function renderRow(item, nowIso){
  const icao = escapeHtml(item.icao);
  const iata = item.iata ? escapeHtml(item.iata) : '';
  const name = item.name ? escapeHtml(item.name) : '';

  const score = Math.round(item.severityScore ?? 0);
  const lvl = levelFromScore(score);

  const metarAge = ageMinutes(item.metarRaw, nowIso);
  const tafAge = ageMinutes(item.tafRaw, nowIso);

  // Table VIS shows METAR visibility in meters (as in your reference screenshot).
  const visM = visNumber(item.visibility_m ?? null);
  const worstVis = visNumber(item.worst_visibility_m ?? item.visibility_m ?? null);
  const lowVisLabel = lowVisLabelFromMeters(worstVis);
  const lowVisCls = visClassFromMeters(worstVis);

  const triggers = buildTriggers(item);

  return `
    <tr>
      <td>
        <div class="airport">
          <div class="airport__codes">
            <span class="airport__icao mono">${icao}</span>
            ${iata ? `<span class="airport__iata mono">${iata}</span>` : ''}
          </div>
          ${name ? `<div class="airport__name">${name}</div>` : ''}
        </div>
      </td>

      <td><span class="${lvl.cls}">${lvl.label}</span></td>

      <td class="mono"><span class="num">${visM == null ? '—' : visM}</span></td>

      <td>${lowVisLabel ? `<span class="hl ${lowVisCls}" data-cat="vis">VIS${lowVisLabel}</span>` : '<span class="muted">—</span>'}</td>

      <td>
        <div class="triggers">
          ${triggers.length
            ? triggers.map(t => `<span class="tag ${tagClass(t)}" data-cat="${tagCat(t)}">${escapeHtml(t.t)}</span>`).join('')
            : `<span class="muted">—</span>`
          }
        </div>
      </td>

      <td>${metarAge == null ? '<span class="muted">—</span>' : `<span class="age">${metarAge}m</span>`}</td>
      <td>${tafAge == null ? '<span class="muted">—</span>' : `<span class="age">${tafAge}m</span>`}</td>

      <td><div class="raw">${item.metarRaw ? highlightRaw(item.metarRaw) : '<span class="muted">No METAR</span>'}</div></td>
      <td><div class="raw">${item.tafRaw ? highlightRaw(item.tafRaw) : '<span class="muted">No TAF</span>'}</div></td>
    </tr>
  `;
}

let state = {
  generatedAt: null,
  stations: [],
  stats: null,
  errors: [],
};

function applyFilters(){
  const text = ($('#filterText').value || '').trim().toUpperCase();
  const cond = $('#condSel').value;
  const alertSel = ($('#alertSel') ? $('#alertSel').value : 'all');
  const sortPriority = $('#sortPriority').checked;

  let rows = state.stations.slice();

  if(text){
    rows = rows.filter(s => {
      const hay = [s.icao, s.iata, s.name].filter(Boolean).join(' ').toUpperCase();
      return hay.includes(text);
    });
  }

  rows = rows.filter(s => conditionMatch(s, cond));
  rows = rows.filter(s => alertMatch(s, alertSel));

  if(sortPriority){
    rows.sort((a,b) => (b.severityScore ?? 0) - (a.severityScore ?? 0) || String(a.icao).localeCompare(String(b.icao)));
  }else{
    rows.sort((a,b) => String(a.icao).localeCompare(String(b.icao)));
  }

  return rows;
}

function render(){
  const tbody = $('#tbody');
  const msg = $('#statusMsg');
  const diag = $('#diag');

  // Recompute ages against current time even if the underlying JSON did not change.
  const nowIso = new Date().toISOString();

  const rows = applyFilters();

  // Status + diagnostics
  const stats = state.stats || null;
  const errList = Array.isArray(state.errors) ? state.errors : [];

  if(stats && (Object.keys(stats).length || errList.length)){
    const parts = [];
    if(stats.icaoCount != null) parts.push(`<b>ICAO</b>: <span class="mono">${escapeHtml(String(stats.icaoCount))}</span>`);
    if(stats.metarReturned != null) parts.push(`<b>METAR</b>: <span class="mono">${escapeHtml(String(stats.metarReturned))}</span>`);
    if(stats.tafReturned != null) parts.push(`<b>TAF</b>: <span class="mono">${escapeHtml(String(stats.tafReturned))}</span>`);
    if(stats.missingMetar != null) parts.push(`<b>Missing METAR</b>: <span class="mono">${escapeHtml(String(stats.missingMetar))}</span>`);
    if(stats.missingTaf != null) parts.push(`<b>Missing TAF</b>: <span class="mono">${escapeHtml(String(stats.missingTaf))}</span>`);

    let html = parts.join(' &nbsp; | &nbsp; ');
    if(errList.length){
      html += `<div style="margin-top:6px" class="err"><b>Errors</b>: ${escapeHtml(errList.join(' | '))}</div>`;
    }
    diag.hidden = false;
    diag.innerHTML = html;
  }else{
    diag.hidden = true;
    diag.innerHTML = '';
  }

  if(state.stations.length === 0){
    msg.textContent = '0 stations loaded. This usually means the GitHub Action did not generate data/latest.json yet (or could not push). Open data/status.json in the repo for the exact error, and ensure you have a workflow under .github/workflows and Actions has Read & write permissions.';
  }else{
    msg.textContent = '';
  }

  tbody.innerHTML = rows.length
    ? rows.map(r => renderRow(r, nowIso)).join('')
    : '<tr><td colspan="9" class="muted">No matching rows.</td></tr>';
}

async function load(){
  const tbody = $('#tbody');
  try{
    // Load main data
    const res = await fetch(`${DATA_URL}?t=${Date.now()}`, { cache: 'no-store' });
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();

    state.generatedAt = data.generatedAt || null;
    state.stations = Array.isArray(data.stations) ? data.stations.map((s) => {
      const rvrMin = computeRvrMin(s);
      return {
        ...s,
        rvrMin,
      };
    }) : [];
    state.stats = data.stats || null;
    state.errors = Array.isArray(data.errors) ? data.errors : [];

    // Also try to load status.json (more reliable diagnostics if latest.json stayed as placeholder)
    try{
      const sres = await fetch(`${STATUS_URL}?t=${Date.now()}`, { cache: 'no-store' });
      if(sres.ok){
        const sdata = await sres.json();
        if(!state.stats && sdata.stats) state.stats = sdata.stats;
        if((!state.errors || !state.errors.length) && Array.isArray(sdata.errors)) state.errors = sdata.errors;
      }
    }catch{ /* ignore */ }

    $('#lastUpdate').textContent = formatGeneratedAt(state.generatedAt);

    render();
  }catch(e){
    tbody.innerHTML = `<tr><td colspan="9" class="muted">Data load error: ${escapeHtml(String(e))}</td></tr>`;
  }
}

let timer = null;
function startTimer(){
  stopTimer();
  timer = setInterval(load, REFRESH_MS);
}
function stopTimer(){
  if(timer) clearInterval(timer);
  timer = null;
}

// Wire UI
$('#refreshBtn').addEventListener('click', () => load());
$('#autoRefresh').addEventListener('change', (e) => e.target.checked ? startTimer() : stopTimer());

['filterText','condSel','alertSel','sortPriority'].forEach(id => {
  const el = $('#' + id);
  if(!el) return;
  el.addEventListener('input', render);
  el.addEventListener('change', render);
});

load();
startTimer();

// Keep the “age” columns current even between 10‑minute data refreshes.
setInterval(() => {
  if(state && Array.isArray(state.stations) && state.stations.length) render();
}, 60 * 1000);
